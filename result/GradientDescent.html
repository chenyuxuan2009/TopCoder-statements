<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" as="font" href="/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2" crossorigin="" type="font/woff2"/><link rel="preload" as="font" href="/_next/static/media/92f44bb82993d879-s.p.woff2" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/d3df112486f97f47.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/ce229e8280b65b88.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/67cd89eb2f8905c7.css" data-precedence="next"/><link rel="preload" href="/_next/static/chunks/webpack-f608cced2fbc4acf.js" as="script" fetchPriority="low"/><script src="/_next/static/chunks/fd9d1056-44fe9588d0e5e7bc.js" async=""></script><script src="/_next/static/chunks/596-8d845297122c6823.js" async=""></script><script src="/_next/static/chunks/main-app-f07f8834a8b67325.js" async=""></script><title>TopCoder Statistics - Problem Statement</title><meta name="description" content="TopCoder Statistics - Problem Archive"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_aaf875"><main><h1><a href="/">Statistics</a></h1><h2>Problem Statement for &quot;<!-- -->GradientDescent<!-- -->&quot;</h2><section class="__className_c9cbed"><article><div><h3>Problem Statement</h3><div>You are writing the scheduler for a small hardware device with a single input peripheral, and a single output peripheral.  Typically, programs that run on the device must make exclusive use of the input for some amount of time, then do a negligible number of calculations and finally make exclusive use of the output for some amount of time.  For example, a program might require 4 seconds of input, and then 2 seconds of output.  We assume that the output may immediately follow the input (but doesn't have to), without delay, and that no time is required before the input, or after the output.  Furthermore, while one program is using the input, no other program may use it, and similarly for the output.  However, one program may use the input while a different program uses the output.  
<br xmlns="http://topcoder.com"/><br xmlns="http://topcoder.com"/>
You have been trying to come up with a good scheduling alogorithm where the time at which all programs are finished is minimized, but are having no luck.  Nothing seems to run fast enough.  So far, you have figured out that once you decide on an order that the programs use the inputs, the optimal output ordering for that input ordering is the same as the input ordering.  Hence, if program i gets to use the input before program j, it should also get to use the output before program j.  However, having made no progress on determining the input order, you decide to try a different approach - gradient descent. 
<br xmlns="http://topcoder.com"/><br xmlns="http://topcoder.com"/>
You will pick a schedule at random, and then repeatedly swap pairs of programs in the schedule, provided that the swap will improve the total time.  Since you know how to order the outputs, given an ordering on the inputs, you only have to worry about swaps in the input ordering.  Hence, your algorithm will roughly follow this pseudocode, where f(P) returns the time taken for all programs to finish when they use the inputs in order P, and use the outputs in some optimal order (given P):
<pre xmlns="http://topcoder.com">
	pick a random ordering, P, for the programs to use the inputs
next:	let T = f(P)
	for each pair of programs p<sub>1</sub> and p<sub>2</sub>
		let P' = P with p<sub>1</sub> and p<sub>2</sub> swapped
		let T' = f(P')
		if(T' &lt; T)
			P = P'
			goto next
		end if
	end for
	return P
</pre>
If there are multiple pairs p<sub xmlns="http://topcoder.com">1</sub> and p<sub xmlns="http://topcoder.com">2</sub> that could be swapped to improve the total time, you've decided to pick the pair whose later program has the earlier end time in P.  In other words, if the two pairs had end times of {6,7} and {3,8}, we would pick the pair with end times {6,7}, since 7 is less than 8.  If there is a tie, then we will pick the pair whose earlier end time is earliest.  Hence we would pick {3,5} over {4,5}.
<br xmlns="http://topcoder.com"/><br xmlns="http://topcoder.com"/>
You've implemented this algorithm, but you've found that it doesn't always give you the optimal schedule.  So, now you want to find out the ratio of the optimal time divided by expected total time from this algorithm for some set of programs.  You will be given a <type xmlns="http://topcoder.com">int[]</type>, <b xmlns="http://topcoder.com">A</b>, and a <type xmlns="http://topcoder.com">int[]</type>, <b xmlns="http://topcoder.com">B</b>, representing the times that a number of programs must use the input device and the output device, respectively.  Corresponding elements of <b xmlns="http://topcoder.com">A</b> and <b xmlns="http://topcoder.com">B</b> represent a single program. </div></div><div><h3>Definition</h3><dl><dt>Class:</dt><dd><span>GradientDescent</span></dd><dt>Method:</dt><dd><span>optimality</span></dd><dt>Parameters:</dt><dd><span>int[], int[]</span></dd><dt>Returns:</dt><dd><span>double</span></dd><dt>Method signature:</dt><dd><span>double optimality(int[] A, int[] B)</span></dd><dt>(be sure your method is public)</dt></dl></div><div><h3>Notes</h3><ul><li>Your return have have an absolute or relative error less than 1e-9.</li></ul></div><div><h3>Constraints</h3><ul><li><span>A and B will contain the same number of elements.</span></li><li><span>A and B will contain between 2 and 9 elements, inclusive.</span></li><li><span>Each element of A and B will be between 1 and 9, inclusive.</span></li></ul></div><div><h3>Examples</h3><ol><li><div><p>{4,3}</p>
<p>{3,2}</p>
<p>Returns: 1.0</p>
<p>Clearly, whenever there are only two programs, we will consider letting each one go first, regardless of our original random order.  Therefore, whenever there are 2 programs, the probability should be 1.</p></div></li><li><div><p>{4,6,8}</p>
<p>{9,3,7}</p>
<p>Returns: 1.0</p>
<p>There are 6 possible orders that for the programs to use the input: {0,1,2}, {0,2,1}, {1,0,2}, {1,2,0}, {2,0,1}, {2,1,0}.
The following table shows the sequences of swaps for each order, along with the total times after swapping.

original order |               swaps                      | total time
---------------+------------------------------------------+-------------
{0,1,2}        | {0,1,2} -> {0,2,1}                       | 23
{0,2,1}        | {0,2,1}                                  | 23
{1,0,2}        | {1,0,2} -> {0,1,2} -> {0,2,1}            | 23
{1,2,0}        | {1,2,0} -> {2,1,0} -> {0,1,2} -> {0,2,1} | 23
{2,0,1}        | {2,0,1} -> {0,2,1}                       | 23
{2,1,0}        | {2,1,0} -> {0,1,2} -> {0,2,1}            | 23
</p></div></li><li><div><p>{4,9,2,1,8}</p>
<p>{8,3,1,7,6}</p>
<p>Returns: 0.9860935524652339</p>
<p>The optimal order to let the programs use the input is {3,0,4,1,2}.  However, if we end up ordering with orders such as {3,2,0,4,1}, then no swap will improve the final time, and we will end up with suboptimal schedules.  However, we happen to end up in one of those schedules fairly infrequently, and their total is only one more, so the ratio is almost 1.</p></div></li><li><div><p>{5,9,7,3,1,5,6,8,3}</p>
<p>{8,3,5,9,7,3,9,5,6}</p>
<p>Returns: 0.993935711083436</p></div></li><li><div><p>{5,9,7,3,1,5,6,8,3}</p>
<p>{6,4,8,4,2,4,7,7,4}</p>
<p>Returns: 0.9765153577782982</p></div></li><li><div><p>{1,8,7,9}
</p>
<p>{4,9,1,2}</p>
<p>Returns: 0.9968051118210863</p></div></li><li><div><p>{1,7,6,3}
</p>
<p>{5,2,4,2}</p>
<p>Returns: 1.0</p></div></li><li><div><p>{5,7,9,9}
</p>
<p>{7,7,1,5}</p>
<p>Returns: 1.0</p></div></li><li><div><p>{5,3,4,8}
</p>
<p>{9,1,2,3}</p>
<p>Returns: 0.9960474308300395</p></div></li><li><div><p>{6,1,9,5}
</p>
<p>{2,1,8,1}</p>
<p>Returns: 1.0</p></div></li><li><div><p>{4,4,7,7,1,8,3,1}
</p>
<p>{8,1,9,2,3,7,4,2}</p>
<p>Returns: 0.9147745807651084</p></div></li><li><div><p>{1,1,1,1,9,7,1,1,1}</p>
<p>{1,2,3,4,5,6,7,8,9}</p>
<p>Returns: 1.0</p></div></li><li><div><p>{5,9,7,3,1,5,6,8,5}</p>
<p>{6,4,8,4,2,4,7,7,4}</p>
<p>Returns: 0.9984506671102231</p></div></li></ol></div></article><hr/><span>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2024, TopCoder, Inc. All rights reserved.</span><hr/></section><section><span>This problem was used for:</span><div><ul></ul></div></section></main><script src="/_next/static/chunks/webpack-f608cced2fbc4acf.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2\",{\"as\":\"font\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/d3df112486f97f47.css\",{\"as\":\"style\"}]\n3:HL[\"/_next/static/css/ce229e8280b65b88.css\",{\"as\":\"style\"}]\n0:\"$L4\"\n"])</script><script>self.__next_f.push([1,"5:HL[\"/_next/static/media/92f44bb82993d879-s.p.woff2\",{\"as\":\"font\",\"type\":\"font/woff2\"}]\n6:HL[\"/_next/static/css/67cd89eb2f8905c7.css\",{\"as\":\"style\"}]\n"])</script><script>self.__next_f.push([1,"7:I{\"id\":7948,\"chunks\":[\"272:static/chunks/webpack-f608cced2fbc4acf.js\",\"971:static/chunks/fd9d1056-44fe9588d0e5e7bc.js\",\"596:static/chunks/596-8d845297122c6823.js\"],\"name\":\"default\",\"async\":false}\n9:I{\"id\":6628,\"chunks\":[\"272:static/chunks/webpack-f608cced2fbc4acf.js\",\"971:static/chunks/fd9d1056-44fe9588d0e5e7bc.js\",\"596:static/chunks/596-8d845297122c6823.js\"],\"name\":\"\",\"async\":false}\na:I{\"id\":7767,\"chunks\":[\"272:static/chunks/webpack-f608cced2fbc4acf.js\",\"971:static/chunks/fd9d1056-44fe9588d0e5e7bc.js\",\"5"])</script><script>self.__next_f.push([1,"96:static/chunks/596-8d845297122c6823.js\"],\"name\":\"default\",\"async\":false}\nb:I{\"id\":7920,\"chunks\":[\"272:static/chunks/webpack-f608cced2fbc4acf.js\",\"971:static/chunks/fd9d1056-44fe9588d0e5e7bc.js\",\"596:static/chunks/596-8d845297122c6823.js\"],\"name\":\"default\",\"async\":false}\ne:I{\"id\":1221,\"chunks\":[\"334:static/chunks/334-8828ae4f59410144.js\",\"185:static/chunks/app/layout-ec819519d0132115.js\"],\"name\":\"\",\"async\":false}\n"])</script><script>self.__next_f.push([1,"4:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d3df112486f97f47.css\",\"precedence\":\"next\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/ce229e8280b65b88.css\",\"precedence\":\"next\"}]],[\"$\",\"$L7\",null,{\"buildId\":\"7VpN_WliezDw3Rx1lULsj\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/ProblemStatement/pm/2370/\",\"initialTree\":[\"\",{\"children\":[\"ProblemStatement\",{\"children\":[\"pm\",{\"children\":[[\"problemId\",\"2370\",\"d\"],{\"children\":[\"__PAGE__?{\\\"problemId\\\":\\\"2370\\\"}\",{}]}]}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[false,\"$L8\"],\"globalErrorComponent\":\"$9\",\"children\":[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_aaf875\",\"children\":[[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"childProp\":{\"current\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"ProblemStatement\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"ProblemStatement\",\"children\",\"pm\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"ProblemStatement\",\"children\",\"pm\",\"children\",[\"problemId\",\"2370\",\"d\"],\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$Lc\",\"$Ld\",null],\"segment\":\"__PAGE__?{\\\"problemId\\\":\\\"2370\\\"}\"},\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/67cd89eb2f8905c7.css\",\"precedence\":\"next\"}]]}],\"segment\":[\"problemId\",\"2370\",\"d\"]},\"styles\":[]}],\"segment\":\"pm\"},\"styles\":[]}],\"segment\":\"ProblemStatement\"},\"styles\":[]}],[\"$\",\"$Le\",null,{}]]}]}],null]}]]\n"])</script><script>self.__next_f.push([1,"8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"TopCoder Statistics - Problem Statement\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"TopCoder Statistics - Problem Archive\"}],[\"$\",\"meta\",\"3\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"link\",\"4\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"5\",{\"name\":\"next-size-adjust\"}]]\nc:null\nf:Te22,"])</script><script>self.__next_f.push([1,"You are writing the scheduler for a small hardware device with a single input peripheral, and a single output peripheral.  Typically, programs that run on the device must make exclusive use of the input for some amount of time, then do a negligible number of calculations and finally make exclusive use of the output for some amount of time.  For example, a program might require 4 seconds of input, and then 2 seconds of output.  We assume that the output may immediately follow the input (but doesn't have to), without delay, and that no time is required before the input, or after the output.  Furthermore, while one program is using the input, no other program may use it, and similarly for the output.  However, one program may use the input while a different program uses the output.  \n\u003cbr xmlns=\"http://topcoder.com\"/\u003e\u003cbr xmlns=\"http://topcoder.com\"/\u003e\nYou have been trying to come up with a good scheduling alogorithm where the time at which all programs are finished is minimized, but are having no luck.  Nothing seems to run fast enough.  So far, you have figured out that once you decide on an order that the programs use the inputs, the optimal output ordering for that input ordering is the same as the input ordering.  Hence, if program i gets to use the input before program j, it should also get to use the output before program j.  However, having made no progress on determining the input order, you decide to try a different approach - gradient descent. \n\u003cbr xmlns=\"http://topcoder.com\"/\u003e\u003cbr xmlns=\"http://topcoder.com\"/\u003e\nYou will pick a schedule at random, and then repeatedly swap pairs of programs in the schedule, provided that the swap will improve the total time.  Since you know how to order the outputs, given an ordering on the inputs, you only have to worry about swaps in the input ordering.  Hence, your algorithm will roughly follow this pseudocode, where f(P) returns the time taken for all programs to finish when they use the inputs in order P, and use the outputs in some optimal order (given P):\n\u003cpre xmlns=\"http://topcoder.com\"\u003e\n\tpick a random ordering, P, for the programs to use the inputs\nnext:\tlet T = f(P)\n\tfor each pair of programs p\u003csub\u003e1\u003c/sub\u003e and p\u003csub\u003e2\u003c/sub\u003e\n\t\tlet P' = P with p\u003csub\u003e1\u003c/sub\u003e and p\u003csub\u003e2\u003c/sub\u003e swapped\n\t\tlet T' = f(P')\n\t\tif(T' \u0026lt; T)\n\t\t\tP = P'\n\t\t\tgoto next\n\t\tend if\n\tend for\n\treturn P\n\u003c/pre\u003e\nIf there are multiple pairs p\u003csub xmlns=\"http://topcoder.com\"\u003e1\u003c/sub\u003e and p\u003csub xmlns=\"http://topcoder.com\"\u003e2\u003c/sub\u003e that could be swapped to improve the total time, you've decided to pick the pair whose later program has the earlier end time in P.  In other words, if the two pairs had end times of {6,7} and {3,8}, we would pick the pair with end times {6,7}, since 7 is less than 8.  If there is a tie, then we will pick the pair whose earlier end time is earliest.  Hence we would pick {3,5} over {4,5}.\n\u003cbr xmlns=\"http://topcoder.com\"/\u003e\u003cbr xmlns=\"http://topcoder.com\"/\u003e\nYou've implemented this algorithm, but you've found that it doesn't always give you the optimal schedule.  So, now you want to find out the ratio of the optimal time divided by expected total time from this algorithm for some set of programs.  You will be given a \u003ctype xmlns=\"http://topcoder.com\"\u003eint[]\u003c/type\u003e, \u003cb xmlns=\"http://topcoder.com\"\u003eA\u003c/b\u003e, and a \u003ctype xmlns=\"http://topcoder.com\"\u003eint[]\u003c/type\u003e, \u003cb xmlns=\"http://topcoder.com\"\u003eB\u003c/b\u003e, representing the times that a number of programs must use the input device and the output device, respectively.  Corresponding elements of \u003cb xmlns=\"http://topcoder.com\"\u003eA\u003c/b\u003e and \u003cb xmlns=\"http://topcoder.com\"\u003eB\u003c/b\u003e represent a single program. "])</script><script>self.__next_f.push([1,"d:[\"$\",\"main\",null,{\"children\":[[\"$\",\"h1\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"/\",\"children\":\"Statistics\"}]}],[\"$\",\"h2\",null,{\"children\":[\"Problem Statement for \\\"\",\"GradientDescent\",\"\\\"\"]}],[\"$\",\"section\",null,{\"className\":\"__className_c9cbed\",\"children\":[[\"$\",\"article\",null,{\"children\":[[\"$\",\"div\",null,{\"children\":[[\"$\",\"h3\",null,{\"children\":\"Problem Statement\"}],[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$f\"}}]]}],[\"$\",\"div\",null,{\"children\":[[\"$\",\"h3\",null,{\"children\":\"Definition\"}],[\"$\",\"dl\",null,{\"children\":[[\"$\",\"dt\",null,{\"children\":\"Class:\"}],[\"$\",\"dd\",null,{\"children\":[\"$\",\"span\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"GradientDescent\"}}]}],[\"$\",\"dt\",null,{\"children\":\"Method:\"}],[\"$\",\"dd\",null,{\"children\":[\"$\",\"span\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"optimality\"}}]}],[\"$\",\"dt\",null,{\"children\":\"Parameters:\"}],[\"$\",\"dd\",null,{\"children\":[\"$\",\"span\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"int[], int[]\"}}]}],[\"$\",\"dt\",null,{\"children\":\"Returns:\"}],[\"$\",\"dd\",null,{\"children\":[\"$\",\"span\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"double\"}}]}],[\"$\",\"dt\",null,{\"children\":\"Method signature:\"}],[\"$\",\"dd\",null,{\"children\":[\"$\",\"span\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"double optimality(int[] A, int[] B)\"}}]}],[\"$\",\"dt\",null,{\"children\":\"(be sure your method is public)\"}]]}]]}],[\"$\",\"div\",null,{\"children\":[[\"$\",\"h3\",null,{\"children\":\"Notes\"}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",\"0\",{\"children\":\"Your return have have an absolute or relative error less than 1e-9.\"}]]}]]}],[\"$\",\"div\",null,{\"children\":[[\"$\",\"h3\",null,{\"children\":\"Constraints\"}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",\"0\",{\"children\":[\"$\",\"span\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"A and B will contain the same number of elements.\"}}]}],[\"$\",\"li\",\"1\",{\"children\":[\"$\",\"span\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"A and B will contain between 2 and 9 elements, inclusive.\"}}]}],[\"$\",\"li\",\"2\",{\"children\":[\"$\",\"span\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"Each element of A and B will be between 1 and 9, inclusive.\"}}]}]]}]]}],[\"$\",\"div\",null,{\"children\":[[\"$\",\"h3\",null,{\"children\":\"Examples\"}],[\"$\",\"ol\",null,{\"children\":[[\"$\",\"li\",\"0\",{\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cp\u003e{4,3}\u003c/p\u003e\\n\u003cp\u003e{3,2}\u003c/p\u003e\\n\u003cp\u003eReturns: 1.0\u003c/p\u003e\\n\u003cp\u003eClearly, whenever there are only two programs, we will consider letting each one go first, regardless of our original random order.  Therefore, whenever there are 2 programs, the probability should be 1.\u003c/p\u003e\"}}]}],[\"$\",\"li\",\"1\",{\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cp\u003e{4,6,8}\u003c/p\u003e\\n\u003cp\u003e{9,3,7}\u003c/p\u003e\\n\u003cp\u003eReturns: 1.0\u003c/p\u003e\\n\u003cp\u003eThere are 6 possible orders that for the programs to use the input: {0,1,2}, {0,2,1}, {1,0,2}, {1,2,0}, {2,0,1}, {2,1,0}.\\nThe following table shows the sequences of swaps for each order, along with the total times after swapping.\\n\\noriginal order |               swaps                      | total time\\n---------------+------------------------------------------+-------------\\n{0,1,2}        | {0,1,2} -\u003e {0,2,1}                       | 23\\n{0,2,1}        | {0,2,1}                                  | 23\\n{1,0,2}        | {1,0,2} -\u003e {0,1,2} -\u003e {0,2,1}            | 23\\n{1,2,0}        | {1,2,0} -\u003e {2,1,0} -\u003e {0,1,2} -\u003e {0,2,1} | 23\\n{2,0,1}        | {2,0,1} -\u003e {0,2,1}                       | 23\\n{2,1,0}        | {2,1,0} -\u003e {0,1,2} -\u003e {0,2,1}            | 23\\n\u003c/p\u003e\"}}]}],[\"$\",\"li\",\"2\",{\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cp\u003e{4,9,2,1,8}\u003c/p\u003e\\n\u003cp\u003e{8,3,1,7,6}\u003c/p\u003e\\n\u003cp\u003eReturns: 0.9860935524652339\u003c/p\u003e\\n\u003cp\u003eThe optimal order to let the programs use the input is {3,0,4,1,2}.  However, if we end up ordering with orders such as {3,2,0,4,1}, then no swap will improve the final time, and we will end up with suboptimal schedules.  However, we happen to end up in one of those schedules fairly infrequently, and their total is only one more, so the ratio is almost 1.\u003c/p\u003e\"}}]}],[\"$\",\"li\",\"3\",{\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cp\u003e{5,9,7,3,1,5,6,8,3}\u003c/p\u003e\\n\u003cp\u003e{8,3,5,9,7,3,9,5,6}\u003c/p\u003e\\n\u003cp\u003eReturns: 0.993935711083436\u003c/p\u003e\"}}]}],[\"$\",\"li\",\"4\",{\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cp\u003e{5,9,7,3,1,5,6,8,3}\u003c/p\u003e\\n\u003cp\u003e{6,4,8,4,2,4,7,7,4}\u003c/p\u003e\\n\u003cp\u003eReturns: 0.9765153577782982\u003c/p\u003e\"}}]}],[\"$\",\"li\",\"5\",{\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cp\u003e{1,8,7,9}\\n\u003c/p\u003e\\n\u003cp\u003e{4,9,1,2}\u003c/p\u003e\\n\u003cp\u003eReturns: 0.9968051118210863\u003c/p\u003e\"}}]}],[\"$\",\"li\",\"6\",{\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cp\u003e{1,7,6,3}\\n\u003c/p\u003e\\n\u003cp\u003e{5,2,4,2}\u003c/p\u003e\\n\u003cp\u003eReturns: 1.0\u003c/p\u003e\"}}]}],[\"$\",\"li\",\"7\",{\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cp\u003e{5,7,9,9}\\n\u003c/p\u003e\\n\u003cp\u003e{7,7,1,5}\u003c/p\u003e\\n\u003cp\u003eReturns: 1.0\u003c/p\u003e\"}}]}],[\"$\",\"li\",\"8\",{\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cp\u003e{5,3,4,8}\\n\u003c/p\u003e\\n\u003cp\u003e{9,1,2,3}\u003c/p\u003e\\n\u003cp\u003eReturns: 0.9960474308300395\u003c/p\u003e\"}}]}],[\"$\",\"li\",\"9\",{\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cp\u003e{6,1,9,5}\\n\u003c/p\u003e\\n\u003cp\u003e{2,1,8,1}\u003c/p\u003e\\n\u003cp\u003eReturns: 1.0\u003c/p\u003e\"}}]}],[\"$\",\"li\",\"10\",{\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cp\u003e{4,4,7,7,1,8,3,1}\\n\u003c/p\u003e\\n\u003cp\u003e{8,1,9,2,3,7,4,2}\u003c/p\u003e\\n\u003cp\u003eReturns: 0.9147745807651084\u003c/p\u003e\"}}]}],[\"$\",\"li\",\"11\",{\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cp\u003e{1,1,1,1,9,7,1,1,1}\u003c/p\u003e\\n\u003cp\u003e{1,2,3,4,5,6,7,8,9}\u003c/p\u003e\\n\u003cp\u003eReturns: 1.0\u003c/p\u003e\"}}]}],[\"$\",\"li\",\"12\",{\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cp\u003e{5,9,7,3,1,5,6,8,5}\u003c/p\u003e\\n\u003cp\u003e{6,4,8,4,2,4,7,7,4}\u003c/p\u003e\\n\u003cp\u003eReturns: 0.9984506671102231\u003c/p\u003e\"}}]}]]}]]}]]}],[\"$\",\"hr\",null,{}],[\"$\",\"span\",null,{\"children\":\"This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2024, TopCoder, Inc. All rights reserved.\"}],[\"$\",\"hr\",null,{}]]}],[\"$\",\"section\",null,{\"children\":[[\"$\",\"span\",null,{\"children\":\"This problem was used for:\"}],[\"$\",\"div\",null,{\"children\":[\"$\",\"ul\",null,{\"children\":[]}]}]]}]]}]\n"])</script></body></html>