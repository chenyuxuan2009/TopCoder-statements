<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" as="font" href="/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2" crossorigin="" type="font/woff2"/><link rel="preload" as="font" href="/_next/static/media/92f44bb82993d879-s.p.woff2" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/d3df112486f97f47.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/ce229e8280b65b88.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/67cd89eb2f8905c7.css" data-precedence="next"/><link rel="preload" href="/_next/static/chunks/webpack-f608cced2fbc4acf.js" as="script" fetchPriority="low"/><script src="/_next/static/chunks/fd9d1056-44fe9588d0e5e7bc.js" async=""></script><script src="/_next/static/chunks/596-8d845297122c6823.js" async=""></script><script src="/_next/static/chunks/main-app-f07f8834a8b67325.js" async=""></script><title>TopCoder Statistics - Problem Statement</title><meta name="description" content="TopCoder Statistics - Problem Archive"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_aaf875"><main><h1><a href="/">Statistics</a></h1><h2>Problem Statement for &quot;<!-- -->NeuralNet<!-- -->&quot;</h2><section class="__className_c9cbed"><article><div><h3>Problem Statement</h3><div><pre xmlns="http://topcoder.com">Class name: NeuralNet
Method name: testTraining
Parameters: int[], int[], int[]
Returns: int[]

You will create a Neural Network.  A Neural Network is used to learn patterns
and relationships in data.  You will train a network with training inputs,
in[].  Once you have trained your network to return the expected training
outputs, out[], send a set of test inputs, testIn[], through the network and
return that output as your result.

The method signature is (be sure your method is declared public):
int[] testTraining(int[] in, int[] out, int[] testIn)

For the purpose of this problem, the neural network contains four nodes.  Each
node takes the int array in[] that contains four elements as input and produces
an int output.  Stored within each node is float array, which contains weights,
w[].  Each element of the weight array is assigned to the element of the same
index of the input array.  For example, if in[0]=1 and w[0]=.5 then in[0] has a
weight of .5 assigned to it.  Each node also has a threshold value, th.

The output of the node is calculated by multiplying each input by its
corresponding weight, and summing all these values.  If the resulting value is
greater than or equal to the threshold value, then node outputs a value of 1,
otherwise, it outputs a 0. For example,

in[0]    -----------------
         |               |
in[1]    |               |
---&gt;|    Node 1     | ---&gt;  x = in[0]*w[0] + in[1]*w[1] + in[2]*w[2] +
in[3]*w[3]
         |               |       if x &gt;= th then out1 = 1  else  out1 = 0
in[2]    |      w[]      |
         |               |
in[3]    |_______________|


in[0]    -----------------
         |               |
in[1]    |               |
---&gt;|    Node 2     | ---&gt;  x = in[0]*w[0] + in[1]*w[1] + in[2]*w[2] +
in[3]*w[3]
         |               |       if x &gt;= th then out2 = 1  else  out2 = 0
in[2]    |      w[]      |
         |               |
in[3]    |_______________|


in[0]    -----------------
         |               |
in[1]    |               |
---&gt;|    Node 3     | ---&gt;  x = in[0]*w[0] + in[1]*w[1] + in[2]*w[2] +
in[3]*w[3]
         |               |       if x &gt;= th then out3 = 1  else  out3 = 0
in[2]    |      w[]      |
         |               |
in[3]    |_______________|


in[0]    -----------------
         |               |
in[1]    |               |
---&gt; |    Node 4     | ---&gt;  x = in[0]*w[0] + in[1]*w[1] + in[2]*w[2] +
in[3]*w[3]
         |               |       if x &gt;= th then out4 = 1  else  out4 = 0
in[2]    |      w[]      |
         |               |
in[3]    |_______________|


TopCoder will enforce the following rules:

*All arrays used for input into the method are of length 4

*The elements of the three input arrays to the method are always 1 or 0.


Notes:

The initial value of all the weights in all the nodes will be 0.25.
The threshold value will be the same for all nodes and will be 0.5.
Every array in this problem begins at index zero.
The delta value (described below) is always equal to 0.10

The value of this neural net is that it can train itself by changing its
internal weights when given an input and the expected output.
The training of a single node is described as follows:


- First, set a "delta" value.  This value is the same all the time, and should
be hard-coded in this problem to 0.10

- Compare the output values of each node to its corresponding element in the
output array.  If they do not match, the internal weights of the node that did
not match must be adjusted.  Adjust the internal weights with a constant
"delta" of 0.1 in the following fashion:

1) if the output matches the expected output, do nothing.
2) if the output is 1, and expected is 0, subtract the "delta" value 0.1 from
the weights that correspond to the inputs that had a value of 1
(If an input was 0, it did not contribute to the output, so its weight should
not be adjusted).
3) if the output is 0, and the expected is 1, add the "delta" value 0.1 to the
weights that correspond to the inputs that had a value of 1.

- Continue to run the set of inputs through the nodes and making these
adjustments until your outputs match the desired outputs.

NOTE:  If, for some reason, you determine that the net is untrainable (i.e., if
input is all zeroes, there is no way to produce any output values which are
non-zero) do not train.

Testing the Trained Neural Network:

Once you have trained your Neural Network, you will utilize the third argument
of test inputs and return the outputs as your result.

Create a method testTraining that takes three int[], representing the node
inputs, the expected outputs and a test case.  The method should return an
int[] that represents the output of the test case after the neural net is
trained.

Example 1: (w1[0] means the weight associated with input 0 in node 1)

trainingInputs = { 1, 0, 0, 0 }, trainingOutputs = { 0, 0, 1, 0 }, testInputs =
{ 0, 1, 1, 0 }

The initial values of the weights (w[i]) are 0.25

After entering { 1, 0, 0, 0 } as inputs,The Outputs are:

(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----&gt; 0),
(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----&gt; 0),
(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----&gt; 0), and
(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----&gt; 0)

Node 0 generates the correct output, so leave it alone.
Node 1 generates the correct output, so leave it alone.
Node 2 does not, so adjust the weights of Node 2:

i[0] = 1 so we can adjust w2[0]: w2[0] = w2[0] + "delta" -- or -- w2[0] = 0.25
+ 0.1 = 0.35 (+ because the current output is too low)
i[1] = 0 so we do not adjust w2[1].
i[2] = 0 so we do not adjust w2[2].
i[3] = 0 so we do not adjust w2[3].

Node 3 generates the correct output, so leave it alone.

After this round of training, the Outputs are:

(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----&gt; 0),
(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----&gt; 0), 
(1 * 0.35 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.35 -----&gt; 0), and
(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----&gt; 0)

and Node 2 still does not generate the correct output, so adjust the weights of
Node 2:

i[0] = 1 so we can adjust w2[0]: w2[0] = w2[0] + "delta" -- or -- w2[0] = 0.35
+ 0.1 = 0.45 (+ because the current output is too low)
i[1] = 0 so we do not adjust w2[1].
i[2] = 0 so we do not adjust w2[2].
i[3] = 0 so we do not adjust w2[3].

After this round of training, the Outputs are:

(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----&gt; 0),
(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----&gt; 0), 
(1 * 0.45 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.45 -----&gt; 0), and
(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----&gt; 0)

and Node 2 still does not generate the correct output, so adjust the weights of
Node 2:

i[0] = 1 so we can adjust w2[0]: w2[0] = w2[0] + "delta" -- or -- w2[0] = 0.45
+ 0.1 = 0.55 (+ because the current output is too low)
i[1] = 0 so we do not adjust w2[1].
i[2] = 0 so we do not adjust w2[2].
i[3] = 0 so we do not adjust w2[3].

After this round of training, the Outputs are:

(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----&gt; 0),
(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----&gt; 0), 
(1 * 0.55 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.55 -----&gt; 1), and
(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----&gt; 0)

And the outputs are the same as the desired outputs.

Now we input the elements of testInput into the net and the Outputs are:

(0 * 0.25 + 1 * 0.25 + 1 * 0.25 + 0 * 0.25 = 0.5 -----&gt; 1),
(0 * 0.25 + 1 * 0.25 + 1 * 0.25 + 0 * 0.25 = 0.5 -----&gt; 1), 
(0 * 0.55 + 1 * 0.25 + 1 * 0.25 + 0 * 0.25 = 0.5 -----&gt; 1), and
(0 * 0.25 + 1 * 0.25 + 1 * 0.25 + 0 * 0.25 = 0.5 -----&gt; 1)

return { 1, 1, 1, 1 }

Example 2: trainingInputs = { 0, 1, 1, 1 } trainingOutputs = { 1, 1, 1, 1 }
testInputs = { 1, 0, 1, 0 }

The initial values of the weights (w[i]) are 0.25. After entering { 0, 1, 1, 1
} as inputs, The Outputs are:

(0 * 0.25 + 1 * 0.25 + 1 * 0.25 + 1 * 0.25 = 0.75 -----&gt; 1),
(0 * 0.25 + 1 * 0.25 + 1 * 0.25 + 1 * 0.25 = 0.75 -----&gt; 1),
(0 * 0.25 + 1 * 0.25 + 1 * 0.25 + 1 * 0.25 = 0.75 -----&gt; 1), and
(0 * 0.25 + 1 * 0.25 + 1 * 0.25 + 1 * 0.25 = 0.75 -----&gt; 1)

All nodes generate the correct output, so we do not train,

Now we input the elements of testInput into the net and the Outputs are:

(1 * 0.25 + 0 * 0.25 + 1 * 0.25 + 0 * 0.25 = 0.5 -----&gt; 1),
(1 * 0.25 + 0 * 0.25 + 1 * 0.25 + 0 * 0.25 = 0.5 -----&gt; 1),
(1 * 0.25 + 0 * 0.25 + 1 * 0.25 + 0 * 0.25 = 0.5 -----&gt; 1), and
(1 * 0.25 + 0 * 0.25 + 1 * 0.25 + 0 * 0.25 = 0.5 -----&gt; 1)

return { 1, 1, 1, 1 }


Example 3: trainingInputs = { 1, 1, 0, 0 } trainingOutputs = { 1, 1, 1, 0 }
testInputs = { 1, 1, 1, 0 }

The initial values of the weights (w[i]) are 0.5. After entering { 1, 1, 0, 0 }
as inputs, the Output is:

(1 * 0.25 + 1 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.5 -----&gt; 1),
(1 * 0.25 + 1 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.5 -----&gt; 1),
(1 * 0.25 + 1 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.5 -----&gt; 1), and
(1 * 0.25 + 1 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.5 -----&gt; 1)

Node 3 is producing the wrong output. Adjust Node 3:

i[0] = 1 so we adjust w3[0]: w3[0] = w3[0] - "delta" -- or -- w3[0] = w3[0] -
0.1 = 0.25 - 0.1 = 0.15  (- because the current output is too low)
i[1] = 1 so we adjust w3[1]: w3[1] = w3[1] - "delta" -- or -- w3[1] = w3[1] -
0.1 = 0.25 - 0.1 = 0.15 (- because the current output is too low)
i[2] = 0 so we do not adjust its corresponding weight.
i[3] = 0 so we do not adjust its corresponding weight.

After this round of training, the Outputs are:

(1 * 0.25 + 1 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.5 -----&gt; 1),
(1 * 0.25 + 1 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.5 -----&gt; 1),
(1 * 0.25 + 1 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.5 -----&gt; 1), and
(1 * 0.15 + 1 * 0.15 + 0 * 0.25 + 0 * 0.25 = 0.3 -----&gt; 0)

and we have the desired output. Now we input the elements of testInput into the
net and the Outputs are:

(1 * 0.25 + 1 * 0.25 + 1 * 0.25 + 0 * 0.25 = 0.75 -----&gt; 1),
(1 * 0.25 + 1 * 0.25 + 1 * 0.25 + 0 * 0.25 = 0.75 -----&gt; 1),
(1 * 0.25 + 1 * 0.25 + 1 * 0.25 + 0 * 0.25 = 0.75 -----&gt; 1), and
(1 * 0.15 + 1 * 0.15 + 1 * 0.25 + 0 * 0.25 = 0.55 -----&gt; 1)

return { 1, 1, 1, 1 }


Example 4: trainingInputs = { 0, 0, 0, 0 } trainingOutputs = { 1, 1, 0, 1 }
testInputs = { 1, 0, 0, 0 }

Since all inputs are zero, we cannot train the net.  Hence, we input the
elements of testInput into the net and the Outputs are:

(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----&gt; 0),
(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----&gt; 0),
(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----&gt; 0), and
(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----&gt; 0)

return { 0, 0, 0, 0 }

</pre></div></div><div><h3>Definition</h3><dl><dt>Class:</dt><dd><span>NeuralNet</span></dd><dt>Method:</dt><dd><span>testTraining</span></dd><dt>Parameters:</dt><dd><span>int[], int[], int[]</span></dd><dt>Returns:</dt><dd><span>int[]</span></dd><dt>Method signature:</dt><dd><span>int[] testTraining(int[] param0, int[] param1, int[] param2)</span></dd><dt>(be sure your method is public)</dt></dl></div><div><h3>Constraints</h3><ul></ul></div><div><h3>Examples</h3><ol></ol></div></article><hr/><span>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2024, TopCoder, Inc. All rights reserved.</span><hr/></section><section><span>This problem was used for:</span><div><ul><li><a href="/ProblemDetail/rd/4003/pm/176">2001-<!-- --> <!-- -->SRM 33<!-- --> - Division <!-- -->I<!-- -->, <!-- -->Level Three</a></li><li><a href="/ProblemDetail/rd/4003/pm/176">2001-<!-- --> <!-- -->SRM 33<!-- --> - Division <!-- -->II<!-- -->, <!-- -->Level Three</a></li></ul></div></section></main><script src="/_next/static/chunks/webpack-f608cced2fbc4acf.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2\",{\"as\":\"font\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/d3df112486f97f47.css\",{\"as\":\"style\"}]\n3:HL[\"/_next/static/css/ce229e8280b65b88.css\",{\"as\":\"style\"}]\n0:\"$L4\"\n"])</script><script>self.__next_f.push([1,"5:HL[\"/_next/static/media/92f44bb82993d879-s.p.woff2\",{\"as\":\"font\",\"type\":\"font/woff2\"}]\n6:HL[\"/_next/static/css/67cd89eb2f8905c7.css\",{\"as\":\"style\"}]\n"])</script><script>self.__next_f.push([1,"7:I{\"id\":7948,\"chunks\":[\"272:static/chunks/webpack-f608cced2fbc4acf.js\",\"971:static/chunks/fd9d1056-44fe9588d0e5e7bc.js\",\"596:static/chunks/596-8d845297122c6823.js\"],\"name\":\"default\",\"async\":false}\n9:I{\"id\":6628,\"chunks\":[\"272:static/chunks/webpack-f608cced2fbc4acf.js\",\"971:static/chunks/fd9d1056-44fe9588d0e5e7bc.js\",\"596:static/chunks/596-8d845297122c6823.js\"],\"name\":\"\",\"async\":false}\na:I{\"id\":7767,\"chunks\":[\"272:static/chunks/webpack-f608cced2fbc4acf.js\",\"971:static/chunks/fd9d1056-44fe9588d0e5e7bc.js\",\"5"])</script><script>self.__next_f.push([1,"96:static/chunks/596-8d845297122c6823.js\"],\"name\":\"default\",\"async\":false}\nb:I{\"id\":7920,\"chunks\":[\"272:static/chunks/webpack-f608cced2fbc4acf.js\",\"971:static/chunks/fd9d1056-44fe9588d0e5e7bc.js\",\"596:static/chunks/596-8d845297122c6823.js\"],\"name\":\"default\",\"async\":false}\ne:I{\"id\":1221,\"chunks\":[\"334:static/chunks/334-8828ae4f59410144.js\",\"185:static/chunks/app/layout-ec819519d0132115.js\"],\"name\":\"\",\"async\":false}\n"])</script><script>self.__next_f.push([1,"4:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d3df112486f97f47.css\",\"precedence\":\"next\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/ce229e8280b65b88.css\",\"precedence\":\"next\"}]],[\"$\",\"$L7\",null,{\"buildId\":\"7VpN_WliezDw3Rx1lULsj\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/ProblemStatement/pm/176/\",\"initialTree\":[\"\",{\"children\":[\"ProblemStatement\",{\"children\":[\"pm\",{\"children\":[[\"problemId\",\"176\",\"d\"],{\"children\":[\"__PAGE__?{\\\"problemId\\\":\\\"176\\\"}\",{}]}]}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[false,\"$L8\"],\"globalErrorComponent\":\"$9\",\"children\":[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_aaf875\",\"children\":[[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"childProp\":{\"current\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"ProblemStatement\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"ProblemStatement\",\"children\",\"pm\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"ProblemStatement\",\"children\",\"pm\",\"children\",[\"problemId\",\"176\",\"d\"],\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$Lc\",\"$Ld\",null],\"segment\":\"__PAGE__?{\\\"problemId\\\":\\\"176\\\"}\"},\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/67cd89eb2f8905c7.css\",\"precedence\":\"next\"}]]}],\"segment\":[\"problemId\",\"176\",\"d\"]},\"styles\":[]}],\"segment\":\"pm\"},\"styles\":[]}],\"segment\":\"ProblemStatement\"},\"styles\":[]}],[\"$\",\"$Le\",null,{}]]}]}],null]}]]\n"])</script><script>self.__next_f.push([1,"8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"TopCoder Statistics - Problem Statement\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"TopCoder Statistics - Problem Archive\"}],[\"$\",\"meta\",\"3\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"link\",\"4\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"5\",{\"name\":\"next-size-adjust\"}]]\nc:null\nf:T2a56,"])</script><script>self.__next_f.push([1,"\u003cpre xmlns=\"http://topcoder.com\"\u003eClass name: NeuralNet\nMethod name: testTraining\nParameters: int[], int[], int[]\nReturns: int[]\n\nYou will create a Neural Network.  A Neural Network is used to learn patterns\nand relationships in data.  You will train a network with training inputs,\nin[].  Once you have trained your network to return the expected training\noutputs, out[], send a set of test inputs, testIn[], through the network and\nreturn that output as your result.\n\nThe method signature is (be sure your method is declared public):\nint[] testTraining(int[] in, int[] out, int[] testIn)\n\nFor the purpose of this problem, the neural network contains four nodes.  Each\nnode takes the int array in[] that contains four elements as input and produces\nan int output.  Stored within each node is float array, which contains weights,\nw[].  Each element of the weight array is assigned to the element of the same\nindex of the input array.  For example, if in[0]=1 and w[0]=.5 then in[0] has a\nweight of .5 assigned to it.  Each node also has a threshold value, th.\n\nThe output of the node is calculated by multiplying each input by its\ncorresponding weight, and summing all these values.  If the resulting value is\ngreater than or equal to the threshold value, then node outputs a value of 1,\notherwise, it outputs a 0. For example,\n\nin[0]    -----------------\n         |               |\nin[1]    |               |\n---\u0026gt;|    Node 1     | ---\u0026gt;  x = in[0]*w[0] + in[1]*w[1] + in[2]*w[2] +\nin[3]*w[3]\n         |               |       if x \u0026gt;= th then out1 = 1  else  out1 = 0\nin[2]    |      w[]      |\n         |               |\nin[3]    |_______________|\n\n\nin[0]    -----------------\n         |               |\nin[1]    |               |\n---\u0026gt;|    Node 2     | ---\u0026gt;  x = in[0]*w[0] + in[1]*w[1] + in[2]*w[2] +\nin[3]*w[3]\n         |               |       if x \u0026gt;= th then out2 = 1  else  out2 = 0\nin[2]    |      w[]      |\n         |               |\nin[3]    |_______________|\n\n\nin[0]    -----------------\n         |               |\nin[1]    |               |\n---\u0026gt;|    Node 3     | ---\u0026gt;  x = in[0]*w[0] + in[1]*w[1] + in[2]*w[2] +\nin[3]*w[3]\n         |               |       if x \u0026gt;= th then out3 = 1  else  out3 = 0\nin[2]    |      w[]      |\n         |               |\nin[3]    |_______________|\n\n\nin[0]    -----------------\n         |               |\nin[1]    |               |\n---\u0026gt; |    Node 4     | ---\u0026gt;  x = in[0]*w[0] + in[1]*w[1] + in[2]*w[2] +\nin[3]*w[3]\n         |               |       if x \u0026gt;= th then out4 = 1  else  out4 = 0\nin[2]    |      w[]      |\n         |               |\nin[3]    |_______________|\n\n\nTopCoder will enforce the following rules:\n\n*All arrays used for input into the method are of length 4\n\n*The elements of the three input arrays to the method are always 1 or 0.\n\n\nNotes:\n\nThe initial value of all the weights in all the nodes will be 0.25.\nThe threshold value will be the same for all nodes and will be 0.5.\nEvery array in this problem begins at index zero.\nThe delta value (described below) is always equal to 0.10\n\nThe value of this neural net is that it can train itself by changing its\ninternal weights when given an input and the expected output.\nThe training of a single node is described as follows:\n\n\n- First, set a \"delta\" value.  This value is the same all the time, and should\nbe hard-coded in this problem to 0.10\n\n- Compare the output values of each node to its corresponding element in the\noutput array.  If they do not match, the internal weights of the node that did\nnot match must be adjusted.  Adjust the internal weights with a constant\n\"delta\" of 0.1 in the following fashion:\n\n1) if the output matches the expected output, do nothing.\n2) if the output is 1, and expected is 0, subtract the \"delta\" value 0.1 from\nthe weights that correspond to the inputs that had a value of 1\n(If an input was 0, it did not contribute to the output, so its weight should\nnot be adjusted).\n3) if the output is 0, and the expected is 1, add the \"delta\" value 0.1 to the\nweights that correspond to the inputs that had a value of 1.\n\n- Continue to run the set of inputs through the nodes and making these\nadjustments until your outputs match the desired outputs.\n\nNOTE:  If, for some reason, you determine that the net is untrainable (i.e., if\ninput is all zeroes, there is no way to produce any output values which are\nnon-zero) do not train.\n\nTesting the Trained Neural Network:\n\nOnce you have trained your Neural Network, you will utilize the third argument\nof test inputs and return the outputs as your result.\n\nCreate a method testTraining that takes three int[], representing the node\ninputs, the expected outputs and a test case.  The method should return an\nint[] that represents the output of the test case after the neural net is\ntrained.\n\nExample 1: (w1[0] means the weight associated with input 0 in node 1)\n\ntrainingInputs = { 1, 0, 0, 0 }, trainingOutputs = { 0, 0, 1, 0 }, testInputs =\n{ 0, 1, 1, 0 }\n\nThe initial values of the weights (w[i]) are 0.25\n\nAfter entering { 1, 0, 0, 0 } as inputs,The Outputs are:\n\n(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----\u0026gt; 0),\n(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----\u0026gt; 0),\n(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----\u0026gt; 0), and\n(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----\u0026gt; 0)\n\nNode 0 generates the correct output, so leave it alone.\nNode 1 generates the correct output, so leave it alone.\nNode 2 does not, so adjust the weights of Node 2:\n\ni[0] = 1 so we can adjust w2[0]: w2[0] = w2[0] + \"delta\" -- or -- w2[0] = 0.25\n+ 0.1 = 0.35 (+ because the current output is too low)\ni[1] = 0 so we do not adjust w2[1].\ni[2] = 0 so we do not adjust w2[2].\ni[3] = 0 so we do not adjust w2[3].\n\nNode 3 generates the correct output, so leave it alone.\n\nAfter this round of training, the Outputs are:\n\n(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----\u0026gt; 0),\n(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----\u0026gt; 0), \n(1 * 0.35 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.35 -----\u0026gt; 0), and\n(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----\u0026gt; 0)\n\nand Node 2 still does not generate the correct output, so adjust the weights of\nNode 2:\n\ni[0] = 1 so we can adjust w2[0]: w2[0] = w2[0] + \"delta\" -- or -- w2[0] = 0.35\n+ 0.1 = 0.45 (+ because the current output is too low)\ni[1] = 0 so we do not adjust w2[1].\ni[2] = 0 so we do not adjust w2[2].\ni[3] = 0 so we do not adjust w2[3].\n\nAfter this round of training, the Outputs are:\n\n(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----\u0026gt; 0),\n(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----\u0026gt; 0), \n(1 * 0.45 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.45 -----\u0026gt; 0), and\n(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----\u0026gt; 0)\n\nand Node 2 still does not generate the correct output, so adjust the weights of\nNode 2:\n\ni[0] = 1 so we can adjust w2[0]: w2[0] = w2[0] + \"delta\" -- or -- w2[0] = 0.45\n+ 0.1 = 0.55 (+ because the current output is too low)\ni[1] = 0 so we do not adjust w2[1].\ni[2] = 0 so we do not adjust w2[2].\ni[3] = 0 so we do not adjust w2[3].\n\nAfter this round of training, the Outputs are:\n\n(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----\u0026gt; 0),\n(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----\u0026gt; 0), \n(1 * 0.55 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.55 -----\u0026gt; 1), and\n(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----\u0026gt; 0)\n\nAnd the outputs are the same as the desired outputs.\n\nNow we input the elements of testInput into the net and the Outputs are:\n\n(0 * 0.25 + 1 * 0.25 + 1 * 0.25 + 0 * 0.25 = 0.5 -----\u0026gt; 1),\n(0 * 0.25 + 1 * 0.25 + 1 * 0.25 + 0 * 0.25 = 0.5 -----\u0026gt; 1), \n(0 * 0.55 + 1 * 0.25 + 1 * 0.25 + 0 * 0.25 = 0.5 -----\u0026gt; 1), and\n(0 * 0.25 + 1 * 0.25 + 1 * 0.25 + 0 * 0.25 = 0.5 -----\u0026gt; 1)\n\nreturn { 1, 1, 1, 1 }\n\nExample 2: trainingInputs = { 0, 1, 1, 1 } trainingOutputs = { 1, 1, 1, 1 }\ntestInputs = { 1, 0, 1, 0 }\n\nThe initial values of the weights (w[i]) are 0.25. After entering { 0, 1, 1, 1\n} as inputs, The Outputs are:\n\n(0 * 0.25 + 1 * 0.25 + 1 * 0.25 + 1 * 0.25 = 0.75 -----\u0026gt; 1),\n(0 * 0.25 + 1 * 0.25 + 1 * 0.25 + 1 * 0.25 = 0.75 -----\u0026gt; 1),\n(0 * 0.25 + 1 * 0.25 + 1 * 0.25 + 1 * 0.25 = 0.75 -----\u0026gt; 1), and\n(0 * 0.25 + 1 * 0.25 + 1 * 0.25 + 1 * 0.25 = 0.75 -----\u0026gt; 1)\n\nAll nodes generate the correct output, so we do not train,\n\nNow we input the elements of testInput into the net and the Outputs are:\n\n(1 * 0.25 + 0 * 0.25 + 1 * 0.25 + 0 * 0.25 = 0.5 -----\u0026gt; 1),\n(1 * 0.25 + 0 * 0.25 + 1 * 0.25 + 0 * 0.25 = 0.5 -----\u0026gt; 1),\n(1 * 0.25 + 0 * 0.25 + 1 * 0.25 + 0 * 0.25 = 0.5 -----\u0026gt; 1), and\n(1 * 0.25 + 0 * 0.25 + 1 * 0.25 + 0 * 0.25 = 0.5 -----\u0026gt; 1)\n\nreturn { 1, 1, 1, 1 }\n\n\nExample 3: trainingInputs = { 1, 1, 0, 0 } trainingOutputs = { 1, 1, 1, 0 }\ntestInputs = { 1, 1, 1, 0 }\n\nThe initial values of the weights (w[i]) are 0.5. After entering { 1, 1, 0, 0 }\nas inputs, the Output is:\n\n(1 * 0.25 + 1 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.5 -----\u0026gt; 1),\n(1 * 0.25 + 1 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.5 -----\u0026gt; 1),\n(1 * 0.25 + 1 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.5 -----\u0026gt; 1), and\n(1 * 0.25 + 1 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.5 -----\u0026gt; 1)\n\nNode 3 is producing the wrong output. Adjust Node 3:\n\ni[0] = 1 so we adjust w3[0]: w3[0] = w3[0] - \"delta\" -- or -- w3[0] = w3[0] -\n0.1 = 0.25 - 0.1 = 0.15  (- because the current output is too low)\ni[1] = 1 so we adjust w3[1]: w3[1] = w3[1] - \"delta\" -- or -- w3[1] = w3[1] -\n0.1 = 0.25 - 0.1 = 0.15 (- because the current output is too low)\ni[2] = 0 so we do not adjust its corresponding weight.\ni[3] = 0 so we do not adjust its corresponding weight.\n\nAfter this round of training, the Outputs are:\n\n(1 * 0.25 + 1 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.5 -----\u0026gt; 1),\n(1 * 0.25 + 1 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.5 -----\u0026gt; 1),\n(1 * 0.25 + 1 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.5 -----\u0026gt; 1), and\n(1 * 0.15 + 1 * 0.15 + 0 * 0.25 + 0 * 0.25 = 0.3 -----\u0026gt; 0)\n\nand we have the desired output. Now we input the elements of testInput into the\nnet and the Outputs are:\n\n(1 * 0.25 + 1 * 0.25 + 1 * 0.25 + 0 * 0.25 = 0.75 -----\u0026gt; 1),\n(1 * 0.25 + 1 * 0.25 + 1 * 0.25 + 0 * 0.25 = 0.75 -----\u0026gt; 1),\n(1 * 0.25 + 1 * 0.25 + 1 * 0.25 + 0 * 0.25 = 0.75 -----\u0026gt; 1), and\n(1 * 0.15 + 1 * 0.15 + 1 * 0.25 + 0 * 0.25 = 0.55 -----\u0026gt; 1)\n\nreturn { 1, 1, 1, 1 }\n\n\nExample 4: trainingInputs = { 0, 0, 0, 0 } trainingOutputs = { 1, 1, 0, 1 }\ntestInputs = { 1, 0, 0, 0 }\n\nSince all inputs are zero, we cannot train the net.  Hence, we input the\nelements of testInput into the net and the Outputs are:\n\n(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----\u0026gt; 0),\n(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----\u0026gt; 0),\n(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----\u0026gt; 0), and\n(1 * 0.25 + 0 * 0.25 + 0 * 0.25 + 0 * 0.25 = 0.25 -----\u0026gt; 0)\n\nreturn { 0, 0, 0, 0 }\n\n\u003c/pre\u003e"])</script><script>self.__next_f.push([1,"d:[\"$\",\"main\",null,{\"children\":[[\"$\",\"h1\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"/\",\"children\":\"Statistics\"}]}],[\"$\",\"h2\",null,{\"children\":[\"Problem Statement for \\\"\",\"NeuralNet\",\"\\\"\"]}],[\"$\",\"section\",null,{\"className\":\"__className_c9cbed\",\"children\":[[\"$\",\"article\",null,{\"children\":[[\"$\",\"div\",null,{\"children\":[[\"$\",\"h3\",null,{\"children\":\"Problem Statement\"}],[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$f\"}}]]}],[\"$\",\"div\",null,{\"children\":[[\"$\",\"h3\",null,{\"children\":\"Definition\"}],[\"$\",\"dl\",null,{\"children\":[[\"$\",\"dt\",null,{\"children\":\"Class:\"}],[\"$\",\"dd\",null,{\"children\":[\"$\",\"span\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"NeuralNet\"}}]}],[\"$\",\"dt\",null,{\"children\":\"Method:\"}],[\"$\",\"dd\",null,{\"children\":[\"$\",\"span\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"testTraining\"}}]}],[\"$\",\"dt\",null,{\"children\":\"Parameters:\"}],[\"$\",\"dd\",null,{\"children\":[\"$\",\"span\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"int[], int[], int[]\"}}]}],[\"$\",\"dt\",null,{\"children\":\"Returns:\"}],[\"$\",\"dd\",null,{\"children\":[\"$\",\"span\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"int[]\"}}]}],[\"$\",\"dt\",null,{\"children\":\"Method signature:\"}],[\"$\",\"dd\",null,{\"children\":[\"$\",\"span\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"int[] testTraining(int[] param0, int[] param1, int[] param2)\"}}]}],[\"$\",\"dt\",null,{\"children\":\"(be sure your method is public)\"}]]}]]}],null,[\"$\",\"div\",null,{\"children\":[[\"$\",\"h3\",null,{\"children\":\"Constraints\"}],[\"$\",\"ul\",null,{\"children\":[]}]]}],[\"$\",\"div\",null,{\"children\":[[\"$\",\"h3\",null,{\"children\":\"Examples\"}],[\"$\",\"ol\",null,{\"children\":[]}]]}]]}],[\"$\",\"hr\",null,{}],[\"$\",\"span\",null,{\"children\":\"This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2024, TopCoder, Inc. All rights reserved.\"}],[\"$\",\"hr\",null,{}]]}],[\"$\",\"section\",null,{\"children\":[[\"$\",\"span\",null,{\"children\":\"This problem was used for:\"}],[\"$\",\"div\",null,{\"children\":[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",\"0\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ProblemDetail/rd/4003/pm/176\",\"children\":[\"2001-\",\" \",\"SRM 33\",\" - Division \",\"I\",\", \",\"Level Three\"]}]}],[\"$\",\"li\",\"1\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ProblemDetail/rd/4003/pm/176\",\"children\":[\"2001-\",\" \",\"SRM 33\",\" - Division \",\"II\",\", \",\"Level Three\"]}]}]]}]}]]}]]}]\n"])</script></body></html>