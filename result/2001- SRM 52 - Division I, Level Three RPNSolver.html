<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" as="font" href="/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2" crossorigin="" type="font/woff2"/><link rel="preload" as="font" href="/_next/static/media/92f44bb82993d879-s.p.woff2" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/d3df112486f97f47.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/ce229e8280b65b88.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/67cd89eb2f8905c7.css" data-precedence="next"/><link rel="preload" href="/_next/static/chunks/webpack-f608cced2fbc4acf.js" as="script" fetchPriority="low"/><script src="/_next/static/chunks/fd9d1056-44fe9588d0e5e7bc.js" async=""></script><script src="/_next/static/chunks/596-8d845297122c6823.js" async=""></script><script src="/_next/static/chunks/main-app-f07f8834a8b67325.js" async=""></script><title>TopCoder Statistics - Problem Statement</title><meta name="description" content="TopCoder Statistics - Problem Archive"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_aaf875"><main><h1><a href="/">Statistics</a></h1><h2>Problem Statement for &quot;<!-- -->RPNSolver<!-- -->&quot;</h2><section class="__className_c9cbed"><article><div><h3>Problem Statement</h3><div><pre xmlns="http://topcoder.com">INTRODUCTION TO RPN

Reverse Polish Notation (RPN) is a way of expressing arithmetic or logic
equations that avoids the need for parentheses.  In infix (normal) notation the
operators (such as +) come between the operands (such as the things being
added), and ambiguity arises about which order to apply the operators.  In RPN,
the evaluation is done from left to right, with the operator coming after its
operands.  An operand may be either a value or the result of a previous
operation.

An RPN expression can be evaluated using a stack with the following method:

   Process the tokens of the expression from left to right.
When an operand (a number or variable reference) is encountered, push it
onto the stack.
When a binary operator is encountered pop two values from the stack, apply
the operator to the values, and push the result.
When a unary operator is encountered pop a single value from the stack,
apply the operator to the value, and push the result.

If the RPN expression is properly formed then after all of the tokens from the
expression have been processed there will be a single value remaining on the
stack.  This value will be the result of the expression.  Consider the expression

   "3 5 + 2 *"

   1. 3 is an operand, so push it onto the stack.
   2. 5 is an operand, so push it onto the stack.
3. + is a binary operator, so pop two values (3 and 5) from the stack, add
them, then push the result (8) onto the stack.
   4. 2 is an operand, so push it onto the stack.
5. * is a binary operator, so pop two values (8 and 2) from the stack,
multiply them, then push the result (16) onto the stack.
6. After all of the tokens are processed the stack contains the single value
16.

So "3 5 + 2 *" evaluates to 16.

PROBLEM STATEMENT

You are to create a class RPNSolver that contains the method countTrue.  The
method should take an RPN expression that may contain references to an unknown
variable X.  The method should return the number of different integral values
of X that make the expression evaluate to true.  The values (operands) in the
expression will be either numeric constants or "X", the unknown value.  The
operators in the expression will be either &lt;, &amp;&amp;, ||, or !.  All numbers
(numeric constants and possible values of X) are constrained to integral values
between 0 and 999,999,999 inclusive.  TopCoder will ensure that the input is
valid.

DEFINITION

Class: RPNSolver
Parameters: String
Returns: int
Method signature: int countTrue(String expr) (make sure your method is public)


NOTES

- The &lt; operator takes two numeric operands and returns true if the left
operand is less than the right operand, false otherwise.
- The &amp;&amp; operator takes two boolean operands and returns true if both operands
are true, false otherwise.
- The || operator takes two boolean operands and returns true if either operand
is true, false otherwise.
- The ! operator takes a single operand and returns true if the operand is
false, false otherwise.

INPUT CONSTRAINTS

TopCoder will ensure that the input is a valid RPN expression.  An expression
is valid if all of the following criteria are met:

- The &lt; operator is always given two numeric operands (X counts as a numeric
operand).
- The &amp;&amp; and || operators are always given two boolean operands.
- The ! operator is always given a single boolean operand.
- The number of binary operators (&lt;, &amp;&amp;, or ||) present in the expression is
equal to 1 less than the number of numeric operands (numeric values or
references to the unknown value X).
- The RPN expression evaluates to a boolean value.

- All operands directly given in expr are either a numeric constant in the
range of 0 to 999,999,999 inclusive or a reference to the unknown value X.
- All operators are chosen from the set [&lt;, &amp;&amp;, ||, !].
- The expression consists of at most 50 characters.
- The elements in the expression are separated by exactly one space.
- There is no space preceding the first element.
- There is no space after the last element.

EXAMPLES

"X 100 &lt; ! X 200 &lt; &amp;&amp;" can be expressed in infix notation as !(X &lt; 100) &amp;&amp; X &lt;
200.  This encodes the test that X is greater than or equal to 100 and X is
less than 200.  There are exactly 100 integral values that satisfy this
constraint (the natural numbers from 100 to 199 inclusive), so the return value
from countTrue should be 100.

"10 10 &lt;" is never true.  No possible value of X can make it true, so the
method returns 0.

"10 20 &lt;" is always true.  All possible values of X are solutions, so the
method returns 1000000000.

"X 100 &lt; ! X 200 &lt; &amp;&amp; X 50 &lt; ||" returns 150.

"X 999 &lt; !" returns 999999001.

"X X &lt;" returns 0.</pre></div></div><div><h3>Definition</h3><dl><dt>Class:</dt><dd><span>RPNSolver</span></dd><dt>Method:</dt><dd><span>countTrue</span></dd><dt>Parameters:</dt><dd><span>String</span></dd><dt>Returns:</dt><dd><span>int</span></dd><dt>Method signature:</dt><dd><span>int countTrue(String param0)</span></dd><dt>(be sure your method is public)</dt></dl></div><div><h3>Constraints</h3><ul></ul></div><div><h3>Examples</h3><ol></ol></div></article><hr/><span>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2024, TopCoder, Inc. All rights reserved.</span><hr/></section><section><span>This problem was used for:</span><div><ul><li><a href="/ProblemDetail/rd/4023/pm/294">2001-<!-- --> <!-- -->SRM 52<!-- --> - Division <!-- -->I<!-- -->, <!-- -->Level Three</a></li><li><a href="/ProblemDetail/rd/4023/pm/294">2001-<!-- --> <!-- -->SRM 52<!-- --> - Division <!-- -->II<!-- -->, <!-- -->Level Three</a></li></ul></div></section></main><script src="/_next/static/chunks/webpack-f608cced2fbc4acf.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2\",{\"as\":\"font\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/d3df112486f97f47.css\",{\"as\":\"style\"}]\n3:HL[\"/_next/static/css/ce229e8280b65b88.css\",{\"as\":\"style\"}]\n0:\"$L4\"\n"])</script><script>self.__next_f.push([1,"5:HL[\"/_next/static/media/92f44bb82993d879-s.p.woff2\",{\"as\":\"font\",\"type\":\"font/woff2\"}]\n6:HL[\"/_next/static/css/67cd89eb2f8905c7.css\",{\"as\":\"style\"}]\n"])</script><script>self.__next_f.push([1,"7:I{\"id\":7948,\"chunks\":[\"272:static/chunks/webpack-f608cced2fbc4acf.js\",\"971:static/chunks/fd9d1056-44fe9588d0e5e7bc.js\",\"596:static/chunks/596-8d845297122c6823.js\"],\"name\":\"default\",\"async\":false}\n9:I{\"id\":6628,\"chunks\":[\"272:static/chunks/webpack-f608cced2fbc4acf.js\",\"971:static/chunks/fd9d1056-44fe9588d0e5e7bc.js\",\"596:static/chunks/596-8d845297122c6823.js\"],\"name\":\"\",\"async\":false}\na:I{\"id\":7767,\"chunks\":[\"272:static/chunks/webpack-f608cced2fbc4acf.js\",\"971:static/chunks/fd9d1056-44fe9588d0e5e7bc.js\",\"5"])</script><script>self.__next_f.push([1,"96:static/chunks/596-8d845297122c6823.js\"],\"name\":\"default\",\"async\":false}\nb:I{\"id\":7920,\"chunks\":[\"272:static/chunks/webpack-f608cced2fbc4acf.js\",\"971:static/chunks/fd9d1056-44fe9588d0e5e7bc.js\",\"596:static/chunks/596-8d845297122c6823.js\"],\"name\":\"default\",\"async\":false}\ne:I{\"id\":1221,\"chunks\":[\"334:static/chunks/334-8828ae4f59410144.js\",\"185:static/chunks/app/layout-ec819519d0132115.js\"],\"name\":\"\",\"async\":false}\n"])</script><script>self.__next_f.push([1,"4:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d3df112486f97f47.css\",\"precedence\":\"next\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/ce229e8280b65b88.css\",\"precedence\":\"next\"}]],[\"$\",\"$L7\",null,{\"buildId\":\"7VpN_WliezDw3Rx1lULsj\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/ProblemStatement/pm/294/\",\"initialTree\":[\"\",{\"children\":[\"ProblemStatement\",{\"children\":[\"pm\",{\"children\":[[\"problemId\",\"294\",\"d\"],{\"children\":[\"__PAGE__?{\\\"problemId\\\":\\\"294\\\"}\",{}]}]}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[false,\"$L8\"],\"globalErrorComponent\":\"$9\",\"children\":[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_aaf875\",\"children\":[[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"childProp\":{\"current\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"ProblemStatement\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"ProblemStatement\",\"children\",\"pm\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"ProblemStatement\",\"children\",\"pm\",\"children\",[\"problemId\",\"294\",\"d\"],\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$Lc\",\"$Ld\",null],\"segment\":\"__PAGE__?{\\\"problemId\\\":\\\"294\\\"}\"},\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/67cd89eb2f8905c7.css\",\"precedence\":\"next\"}]]}],\"segment\":[\"problemId\",\"294\",\"d\"]},\"styles\":[]}],\"segment\":\"pm\"},\"styles\":[]}],\"segment\":\"ProblemStatement\"},\"styles\":[]}],[\"$\",\"$Le\",null,{}]]}]}],null]}]]\n"])</script><script>self.__next_f.push([1,"8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"TopCoder Statistics - Problem Statement\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"TopCoder Statistics - Problem Archive\"}],[\"$\",\"meta\",\"3\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"link\",\"4\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"5\",{\"name\":\"next-size-adjust\"}]]\nc:null\nf:T12ad,"])</script><script>self.__next_f.push([1,"\u003cpre xmlns=\"http://topcoder.com\"\u003eINTRODUCTION TO RPN\n\nReverse Polish Notation (RPN) is a way of expressing arithmetic or logic\nequations that avoids the need for parentheses.  In infix (normal) notation the\noperators (such as +) come between the operands (such as the things being\nadded), and ambiguity arises about which order to apply the operators.  In RPN,\nthe evaluation is done from left to right, with the operator coming after its\noperands.  An operand may be either a value or the result of a previous\noperation.\n\nAn RPN expression can be evaluated using a stack with the following method:\n\n   Process the tokens of the expression from left to right.\nWhen an operand (a number or variable reference) is encountered, push it\nonto the stack.\nWhen a binary operator is encountered pop two values from the stack, apply\nthe operator to the values, and push the result.\nWhen a unary operator is encountered pop a single value from the stack,\napply the operator to the value, and push the result.\n\nIf the RPN expression is properly formed then after all of the tokens from the\nexpression have been processed there will be a single value remaining on the\nstack.  This value will be the result of the expression.  Consider the expression\n\n   \"3 5 + 2 *\"\n\n   1. 3 is an operand, so push it onto the stack.\n   2. 5 is an operand, so push it onto the stack.\n3. + is a binary operator, so pop two values (3 and 5) from the stack, add\nthem, then push the result (8) onto the stack.\n   4. 2 is an operand, so push it onto the stack.\n5. * is a binary operator, so pop two values (8 and 2) from the stack,\nmultiply them, then push the result (16) onto the stack.\n6. After all of the tokens are processed the stack contains the single value\n16.\n\nSo \"3 5 + 2 *\" evaluates to 16.\n\nPROBLEM STATEMENT\n\nYou are to create a class RPNSolver that contains the method countTrue.  The\nmethod should take an RPN expression that may contain references to an unknown\nvariable X.  The method should return the number of different integral values\nof X that make the expression evaluate to true.  The values (operands) in the\nexpression will be either numeric constants or \"X\", the unknown value.  The\noperators in the expression will be either \u0026lt;, \u0026amp;\u0026amp;, ||, or !.  All numbers\n(numeric constants and possible values of X) are constrained to integral values\nbetween 0 and 999,999,999 inclusive.  TopCoder will ensure that the input is\nvalid.\n\nDEFINITION\n\nClass: RPNSolver\nParameters: String\nReturns: int\nMethod signature: int countTrue(String expr) (make sure your method is public)\n\n\nNOTES\n\n- The \u0026lt; operator takes two numeric operands and returns true if the left\noperand is less than the right operand, false otherwise.\n- The \u0026amp;\u0026amp; operator takes two boolean operands and returns true if both operands\nare true, false otherwise.\n- The || operator takes two boolean operands and returns true if either operand\nis true, false otherwise.\n- The ! operator takes a single operand and returns true if the operand is\nfalse, false otherwise.\n\nINPUT CONSTRAINTS\n\nTopCoder will ensure that the input is a valid RPN expression.  An expression\nis valid if all of the following criteria are met:\n\n- The \u0026lt; operator is always given two numeric operands (X counts as a numeric\noperand).\n- The \u0026amp;\u0026amp; and || operators are always given two boolean operands.\n- The ! operator is always given a single boolean operand.\n- The number of binary operators (\u0026lt;, \u0026amp;\u0026amp;, or ||) present in the expression is\nequal to 1 less than the number of numeric operands (numeric values or\nreferences to the unknown value X).\n- The RPN expression evaluates to a boolean value.\n\n- All operands directly given in expr are either a numeric constant in the\nrange of 0 to 999,999,999 inclusive or a reference to the unknown value X.\n- All operators are chosen from the set [\u0026lt;, \u0026amp;\u0026amp;, ||, !].\n- The expression consists of at most 50 characters.\n- The elements in the expression are separated by exactly one space.\n- There is no space preceding the first element.\n- There is no space after the last element.\n\nEXAMPLES\n\n\"X 100 \u0026lt; ! X 200 \u0026lt; \u0026amp;\u0026amp;\" can be expressed in infix notation as !(X \u0026lt; 100) \u0026amp;\u0026amp; X \u0026lt;\n200.  This encodes the test that X is greater than or equal to 100 and X is\nless than 200.  There are exactly 100 integral values that satisfy this\nconstraint (the natural numbers from 100 to 199 inclusive), so the return value\nfrom countTrue should be 100.\n\n\"10 10 \u0026lt;\" is never true.  No possible value of X can make it true, so the\nmethod returns 0.\n\n\"10 20 \u0026lt;\" is always true.  All possible values of X are solutions, so the\nmethod returns 1000000000.\n\n\"X 100 \u0026lt; ! X 200 \u0026lt; \u0026amp;\u0026amp; X 50 \u0026lt; ||\" returns 150.\n\n\"X 999 \u0026lt; !\" returns 999999001.\n\n\"X X \u0026lt;\" returns 0.\u003c/pre\u003e"])</script><script>self.__next_f.push([1,"d:[\"$\",\"main\",null,{\"children\":[[\"$\",\"h1\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"/\",\"children\":\"Statistics\"}]}],[\"$\",\"h2\",null,{\"children\":[\"Problem Statement for \\\"\",\"RPNSolver\",\"\\\"\"]}],[\"$\",\"section\",null,{\"className\":\"__className_c9cbed\",\"children\":[[\"$\",\"article\",null,{\"children\":[[\"$\",\"div\",null,{\"children\":[[\"$\",\"h3\",null,{\"children\":\"Problem Statement\"}],[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$f\"}}]]}],[\"$\",\"div\",null,{\"children\":[[\"$\",\"h3\",null,{\"children\":\"Definition\"}],[\"$\",\"dl\",null,{\"children\":[[\"$\",\"dt\",null,{\"children\":\"Class:\"}],[\"$\",\"dd\",null,{\"children\":[\"$\",\"span\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"RPNSolver\"}}]}],[\"$\",\"dt\",null,{\"children\":\"Method:\"}],[\"$\",\"dd\",null,{\"children\":[\"$\",\"span\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"countTrue\"}}]}],[\"$\",\"dt\",null,{\"children\":\"Parameters:\"}],[\"$\",\"dd\",null,{\"children\":[\"$\",\"span\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"String\"}}]}],[\"$\",\"dt\",null,{\"children\":\"Returns:\"}],[\"$\",\"dd\",null,{\"children\":[\"$\",\"span\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"int\"}}]}],[\"$\",\"dt\",null,{\"children\":\"Method signature:\"}],[\"$\",\"dd\",null,{\"children\":[\"$\",\"span\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"int countTrue(String param0)\"}}]}],[\"$\",\"dt\",null,{\"children\":\"(be sure your method is public)\"}]]}]]}],null,[\"$\",\"div\",null,{\"children\":[[\"$\",\"h3\",null,{\"children\":\"Constraints\"}],[\"$\",\"ul\",null,{\"children\":[]}]]}],[\"$\",\"div\",null,{\"children\":[[\"$\",\"h3\",null,{\"children\":\"Examples\"}],[\"$\",\"ol\",null,{\"children\":[]}]]}]]}],[\"$\",\"hr\",null,{}],[\"$\",\"span\",null,{\"children\":\"This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2024, TopCoder, Inc. All rights reserved.\"}],[\"$\",\"hr\",null,{}]]}],[\"$\",\"section\",null,{\"children\":[[\"$\",\"span\",null,{\"children\":\"This problem was used for:\"}],[\"$\",\"div\",null,{\"children\":[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",\"0\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ProblemDetail/rd/4023/pm/294\",\"children\":[\"2001-\",\" \",\"SRM 52\",\" - Division \",\"I\",\", \",\"Level Three\"]}]}],[\"$\",\"li\",\"1\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ProblemDetail/rd/4023/pm/294\",\"children\":[\"2001-\",\" \",\"SRM 52\",\" - Division \",\"II\",\", \",\"Level Three\"]}]}]]}]}]]}]]}]\n"])</script></body></html>